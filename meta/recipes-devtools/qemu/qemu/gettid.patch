--- qemu-2.8.0/linux-user/syscall.c	2016-12-20 14:16:48.000000000 -0600
+++ qemu-2.8.0/linux-user/syscall.c.new	2022-12-20 13:41:53.314398259 -0600
@@ -253,11 +253,15 @@
 #endif
 
 #ifdef __NR_gettid
-_syscall0(int, gettid)
+static int sys_gettid(void)
+{
+    return syscall(__NR_gettid);
+}
 #else
 /* This is a replacement for the host gettid() and must return a host
    errno. */
-static int gettid(void) {
+static int sys_gettid(void)
+{
     return -ENOSYS;
 }
 #endif
@@ -6071,7 +6075,7 @@
     cpu = ENV_GET_CPU(env);
     thread_cpu = cpu;
     ts = (TaskState *)cpu->opaque;
-    info->tid = gettid();
+    info->tid = sys_gettid();
     cpu->host_tid = info->tid;
     task_settid(ts);
     if (info->child_tidptr)
@@ -6217,9 +6221,9 @@
                mapping.  We can't repeat the spinlock hack used above because
                the child process gets its own copy of the lock.  */
             if (flags & CLONE_CHILD_SETTID)
-                put_user_u32(gettid(), child_tidptr);
+                put_user_u32(sys_gettid(), child_tidptr);
             if (flags & CLONE_PARENT_SETTID)
-                put_user_u32(gettid(), parent_tidptr);
+                put_user_u32(sys_gettid(), parent_tidptr);
             ts = (TaskState *)cpu->opaque;
             if (flags & CLONE_SETTLS)
                 cpu_set_tls (env, newtls);
@@ -11207,7 +11211,7 @@
         break;
 #endif
     case TARGET_NR_gettid:
-        ret = get_errno(gettid());
+        ret = get_errno(sys_gettid());
         break;
 #ifdef TARGET_NR_readahead
     case TARGET_NR_readahead:
